\input{document-info}

\section{Regular Languages}
\label{regularlanguages}

A language is regular if and only if it is recognized by a DFA, NFA, or Regexp.

\textbf{DFA} $M = (Q, \Sigma, \delta, R, q_0 \in Q, F \subseteq Q)$

\textbf{NFA} DFA but with epsilon transitions. DFA equivalent: each dfa state represents some subset of NFA states.

\subsection{Regular Expressions}
\label{regularexpressions}

A regexp over $\Sigma$ is one of $a\in \Sigma,\epsilon,\emptyset,(R_1\cup R_2),(R_1\circ R_2),R_1^* $ where each $R_i$ is a regexp.

\textbf{Closure Properties} $\cup,\,\cap,\, \circ,\, \star,\, \bar{A}$

\subsection{Pumping Lemma for RLs}
\label{pumpinglemmaforrls}

Let $A$ be a regular language. There must exist some $p \geq 1 $ such that for all $w\in A\, :\, |w| \geq p$ there is some split $w = xyz$:

\begin{enumerate}
\item $xy^iz \in A$ for all $i \geq 0$

\item $|y| \geq 0$

\item $|xy| \leq |p|$

\end{enumerate}

This is a necessary but not sufficient condition to be a regular language!

\subsection{Non-{}regular Languages}
\label{non-regularlanguages}

\begin{itemize}
\item $0^n1^n\, |\, n\geq 0 $

\end{itemize}

\section{Context Free Languages}
\label{contextfreelanguages}

A Language is Context Free if and only if it is recognized by a PDA or generated by a CFG. All regular languages are context free but not all context free languages are regular! Every DFA is a PDA that ignores its stack.

\subsection{PDA}
\label{pda}

Think NFA but with a stack. $P = (Q, \Sigma, \Gamma, \delta, q_0, F)$

\subsection{CFG}
\label{cfg}

$ G = (V, \Sigma, R, S) $. Grammars \emph{derive} strings. Ambiguity: can have multiple parse trees for a single grammar!

\begin{itemize}
\item $V$ are VARIABLES and disjoint from the set of terminals

\item $\Sigma$ are the terminals

\item $R\, :\, V \times (V \cup \Sigma)^*$ are production rules

\end{itemize}

\subsection{PDA \& CFG Equivalence}
\label{pdacfgequivalence}

Construct a PDA from a CFG G with the same language:

\begin{itemize}
\item PDA P with input w. Push sentinel \$, then S

\item Loop

\begin{itemize}
\item if top of stack is a var \textbackslash{}(S\textbackslash{}in V) pop it \& nondeterministically choose a rule for S. Push the RHS of rule in reverse order on to the stack

\item if top of stack is a terminal, pop then match with next input symbol. If equivalent, continue, else \emph{reject}

\item if top of stack is \$ and input is empty then enter accept state

\end{itemize}

\end{itemize}

Construct a CFG from a PDA P:

\begin{itemize}
\item Grammar G has variables $A_{pq}$ for all $p,q\in Q$

\item $A_{pq}$ will be able to derive exactly those strings which can send state p with empty stack to state q with empty stack

\item $S = A_{q_0q_{acc}}$ : anything that sends from start to end with empty stack

\item Rules have two options:

\begin{itemize}
\item the first push char must be the last pop char: $A_{pq} \to aA_{rs}b$ where r is the state after p and s is the last state before q and a is the input read at the first move and b the input read at the last move.
-{}If the stack is emptied before q then we have $ A_{pq} \to A_{pr}A_{rq} $ where r is the state when the stack becomes empty.

\end{itemize}

\end{itemize}

\subsection{Closure Properties}
\label{closureproperties}

$\cup,A^* ,\circ$ and also the following lemma: if $C$ is a CFL and $R$ is a regular language then $C\cap R$ is a CFL. Corollary: if $R$ is a regular language and $A\cap R$ is a non-{}CFL then $A$ is a non-{}CFL.

\subsection{Pumping Lemma for CFLs}
\label{pumpinglemmaforcfls}

Let $A$ be a context free language. There must exist some $p \geq 1 $ such that for all $w\in A\, :\, |w| \geq p$ there is some split $w = uvxyz$:

\begin{enumerate}
\item $ uv^ixy^iz \in A $ for all $i\geq 0$

\item $ |vy| \geq 1 $ v and y cannot both be $\epsilon$

\item $ |vxy| \leq p$

\end{enumerate}

This is due to the pigeonhole principle: for a sufficiently long parse tree for a CFG (height of tree greater than number of variables) \emph{some} variable $R$ must be repeated!
This is a necessary but not sufficient condition to be a CFL!

\subsection{Non-{}Context Free Languages}
\label{non-contextfreelanguages}

Can prove a language is not context free either by the pumping lemma or the closure properties.

\begin{itemize}
\item $\{ a^nb^nc^n\, |\, n \geq 0 \}$ cannot pump when $n = p$

\item $\{ ww\, |\, w\in \{0,1\}^* \}$ cannot pump string $w = 0^P1^P0^P1^P$

\item $\{ w\in \{a,b,c,d\}^* \}$ where $\#as = \#bs, \#cs = \#ds$ -{} proved through lemma with $\cap R = \{a^nb^nc^md^m|n,m\geq 0\}$ $a^Pc^Pb^Pd^P$

\end{itemize}

\section{Turing Machines}
\label{turingmachines}

$M = (Q,\Sigma,\Gamma,\delta,q_0, q_{acc}, q_{rej})$ Has a finite state control with infinite tape. Has read head, can move $L,R$.

A configuration $uqv$ states that the read head $q\in Q$ of the machine is at the leftmost symbol of $v$ where $u,v\in \Gamma^*$ represent the contents of the tape.

A TM \emph{accepts} on input if the sequence of configs from the start config, given by $\delta$ reaches the accept state in some \emph{finite number of steps}. A TM \emph{rejects} on input if the sequence of configs from the start config, given by $\delta$ reaches the reject state in some \emph{finite number of steps}.

\subsection{Church-{}Turing Thesis}
\label{church-turingthesis}

Turing-{}machines can compute \emph{anything} that can be computed -{} we define ``what can be computed'' as ``what can be computed by a Turing-{}machine''

\subsection{Recognizability}
\label{recognizability}

A TM \emph{recognizes} a language if it

\begin{enumerate}
\item accepts $\forall w\in L$

\item rejects \textbf{or} loops $\forall w\notin L$.

\end{enumerate}

Recognizable languages are closed under: $\cup,\cap,A^*,\circ$. These are also known as ``recursively-{}enumerable'' languages.

\subsection{Decidability}
\label{decidability}

A TM \emph{decides} a language if it

\begin{enumerate}
\item accepts $\forall w\in L$

\item rejects $\forall w\notin L$ and \emph{does not loop}

\end{enumerate}

Decidable languages are closed under: $\cup, \circ, A^*, \cap,\bar{A}$

\subsection{Equivalent Variants}
\label{equivalentvariants}

\begin{itemize}
\item K-{}Tape Turing machines -{} can be emulated with a single tape turing machine by putting all k tapes on the single tape with dividers, etc

\item Nondeterministic Turing Machines -{} can be emulated with a 3-{}tape turing machine: 1st tape input, 2nd tape simulation, 3rd tape address (think BFS of the computation tree). An NTM accepts if some thread reaches the accept state. An NTM rejects if all threads terminate and reject. An NTM loops in any other case.

\end{itemize}

Proof of NTM and TM equivalence: 3-{}tape TM as above. If any simulated branch accepts then accept. If all locations of some length\slash depth reject then reject.

Why BFS instead of DFS for a NTM? Because DFS may go forever down a branch, and BFS ensures that the NTM will visit every node in the tree until it encounters and accepting configuration!

\vfill \columnbreak

\subsection{Enumerators}
\label{enumerators}

An enumerator is a special type of TM with two tapes: one work tape (same as a normal tape) and one write-{}only printer (or output tape). Writes strings separated by a \# to output tape. $L(E) = \{w\, :\, E\; outputs\; w\; eventually\}$. A language is \textbf{enumerable} if it is the language of some enumerator. Enumerators do not necessarily halt.

\subsection{Enumerabilty, Recognizability}
\label{enumerabiltyrecognizability}

A language is \emph{enumerable} $\Leftrightarrow$ it is \emph{recognizable}.

Proof: enumerable $\Rightarrow$ recognizable. Given E for language, build a TM M that recognizes as follows: run E and if the input $w$ ever appears on its ouput tape then accept. If E halts reject. If $w\in L$ then E eventually outputs w. If $w\notin L$ then E never outputs w, no M either loops or rejects.

Proof: recognizable $\Rightarrow$ enumerable. Given TM M that recognizes L build E. Consider strings in $\Sigma^*$ in some order: $w_1=\epsilon,w_2=0,\dotsc$. For $i=1,2,\dotsc$ for each string $w_j,1\leq j\leq i$ run M for up to i steps. If M ever accepts then print $w_j$.

For any string $w\in \Sigma^*$ $E$ eventually runs M for any desired finite number of steps.

\input{x3-notes-end}

\end{document}